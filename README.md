Personal records for practice of data structure and algorithm.

This file serves as a catalog for this repository.



# 算法集训

## 常见思路

别超数据范围

### 暴力&枚举

#### 洛谷P1003

铺地毯问题

每次得到地毯后对矩形区域进行赋值会产生大量冗余操作

不如先得到所有地毯编号，然后对查询点，遍历地毯，得到最后的地毯编号



#### LC 59

正方形内生产螺旋矩阵

一次做完一行/列



#### 洛谷P1328

生活大爆炸石头剪刀布

- 两人各自规律性出拳,赢了加1分,其余不得分

没啥好说的，打表枚举就完事



### 前缀和 & 差分

——避免大量重复计算

1. 一维: 顺着加就完事了
2. 二维：sum\[i][j] = sum\[i-1][j] + sum\[i][j-1] + a\[i][j] - sum\[i-1][j-1]
   - i，j从1开始，矩阵sum\[0][j]和sum\[i][0]初始化为0

#### 已知数组和的数组，怎么求原数组？——差分问题

1. 一维：顺着减
2. 二维：a\[i][j] = sum\[i][j] -sum\[i-1][j] - sum\[i][j-1] +sum\[i-1][j-1]

#### more？

1. n*n个数，求(x1,y1)到(x2,y2)矩形区域的和(x1<x2,y1<y2)
   - 容斥原理的进一步应用
2. 对某区间内数字加一个数，有多次这样的操作，求该数组最终的状态
   - 标记数组，mark[l] += num，mark[r+1] -= num，求mark数组的和数组后，加到原数组上
3. 上述情况的二维情形？
   - 定义：对(x1, y1), (x2, y2)为对角顶点的矩阵加数，有多次这样的操作，求最终的矩阵
   - 分析：对于和数组，对原矩阵的某顶点加数，相当于对和矩阵从某顶点开始无限向右下延申的所有顶点加数
   - 则：mark\[x1][y1] += num, mark\[x2+1][y2+1] -= num, mark\[x2+1][y1] -= num，mark\[x1][y2+1] -= num

#### 例题

##### 洛谷B3612

##### 洛谷P1387

？？？？看不懂看不懂

##### 洛谷P3397

```C++
/* 总体思路：对于每张地毯，有：
        carpet[x1][y1]+=1,carpet[x2+1][y2+1]+=1,carpet[x1][y2+1]-=1,carpet[x2+1][y1]-=1
    对地毯矩阵求和，即可得到每个格子实际覆盖的地毯数目：
        sum[i][j]=carpet[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]
    输出即可
 */
```

### 双指针/滑动窗口/尺取法

——一种高效的枚举`连续区间`的方法，通用思路为：

1. 双指针`标记目标区间`，每当符合要求时，`记录`当前状态，继续滑动窗口
2. 如果是一开始就符合要求的呢？应一次性计算完区间内所有符合要求的区间，等下一次符合要求时，继续该操作

#### LCR008

#### LC713

#### LC2379

  /* lr从0开始染色，mark(01)数组标记染色，和为操作数

​    区间长度小于k则r继续右移，碰到白的就记录，统计白的个数——即寻求长度为k的区间内，白色最少的数目

​    一旦区间长度==k，记录当前白色数是否最小，l右移至白色——其余区间白色数一定相同

​    r继续右移至长度等于k...l右移至下一个白色...r右移至...

   */

...先设计再写代码真爽

### 二分

二分的本质：某个`区间内猜可能的答案`，用猜的答案`反向验证`该答案是否正确

- 更牛逼的暴力枚举

应用场景？答案在某区间内的都可以猜

1. 可以把O(n)优化到O(logn)
2. note：`定义区间`很重要，[]闭区间还是[)左开右闭，需要遍历完毕整个区间
3. 应用：猜一个解判断是否可行：最小化最大值/最大化最小值....

#### 洛谷P2678 跳石头

  /* solution：

​    答案区间[1,n]，假设ans为最长最短距离，要求当前石头到下一块石头间距离>=ans，

​      否则移走后面的石头，计数+1

​    若移走的石头大于M，则ans大了;小于M则有可能为答案，记录;当l>r，区间内再无可能的答案，退出

​    更新区间

  */

似乎有些bug，但问题不大

#### LCR073 猴子吃香蕉

  /* 吃的速度可能为:[1,max(piles)]或[1,10^9]

​    反向验证得到耗时，比较耗时：

​    若time>h，则吃得太慢了，l=mid+1;若time<=h，则有可能为答案，更新final_k，r=mid-1

   */

### 贪心

——不绝对最优，但至少不差

#### 洛谷P1090

涉及到优先队列，日后再说

#### 洛谷P4995 跳跳

——不能用int，得换long long

  /* solution：先排个序，永远跳到落差最大的石头上 */

#### LC 2611 老鼠吃奶酪

/* 老鼠吃奶酪

  1 1 3 4 vs.

  4 4 1 1

  第一只老鼠吃掉其中的k块，求得分最大

  二者相减得：

  -3 -3 2 3，小于0则应第二只老鼠吃，否则第一只老鼠吃

  那么问题转化为：让第一只老鼠吃掉此数组中最大的k个奶酪，在k=2时，为3，4；第二只老鼠吃：4，4



  则吃的方案为：

​    第二只老鼠吃完;第一只老鼠吃相对于它的差值的前k个

 */



### 递归与分治

`划分同类子问题`，生成递归树，寻找边界条件

- 一种思路：小样例推导递归代码

#### LC08.06 汉诺塔

#### LC53 最大子数组和

？

## 基础数据结构

### 链表

#### LC206 反转链表

##### 三指针法

  /* 指针一：指向prev node，指针二：需当前需要反转指向的node，指针三：指向下一个node

​    2->1，1=2，2=3, 3->4,什么时候终止？2==nullptr

   */

##### 头插法

head永远指向头，next指向需要反转的node：

1. next != nullptr时：
2. head->next = next; next = next->next; head = next

over

#### LCR140 倒数第n个结点

先统计一共有多少个结点，再找到固定位置即可

#### LC142 循环链表入结点

  /* 法1：哈希表 */

  /* 法2：快慢指针法

​    note 1：有循环的话，不断next下去永远结束不了

​    note 2：如果两个指针的相对速度为1，那么在有循环的情况下，二者终将相遇

​    note 3：发现一个nullptr就不干了！

   */

然后就是一定的数学公式推导...推一下

#### LC1206 设计跳表

？pass








# 牛客

## HJ

#### 找到最后一个单词长度

- 先进行思路设计，再写代码...不然简单题都能坑死你
- 带空格的字符串输入要用`getline(cin, str)`，单纯cin会被空格中止

#### 统计字符串中某字符出现的次数

- 不区分大小写——先统一转换为小写